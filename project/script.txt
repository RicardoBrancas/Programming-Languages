#

So today I'm going to talk about program synthesis.

# 1

# 2

Suppose you have a specification for some piece of software, normally you would have to write it, test it and so on. But what if you don't want to do this (or imagine you don't even know how to program).

$

That is the problem program synthesis tries to solve.
These specifications can be as simple as just a set of input/output examples or as formal a logic specification.

# 3

But before we try to tackle this problem, how can we check if a some program respects a given specification?

$

We can reduce this to a logic formulation and use an off the shelf solver to find out.

# 4

Let's see how we can do this.

# 5

As most of you have probably learned from previous courses, first-order logic is a superset of the propositional logic.

Here we have an example of propositional:
- P and Q
- Q implies P or R

$

First-order logic introduces predicates, functions and quantifiers.
As you can see:
- For all x, P(x)
- Exists y such that for all x, Q(y, x) and P(f(y))

$

There is problem however: first order logic is undecidable

# 6

We say that a problem in decidable if there is a way of always deriving the correct answer.
This problem of undecidablity means we cannot create an algorithm that says wether a given first order formula is satisfiable.

$

So how can we do it?

# 7

The solution is to only use the parts of first-order logic that are decidable, which are called theories.
This technique is called satisfiability modulo theories.

Here we have an example of one such theory: TODO

$

And here another one

# 8

We call the possible solutions to formulas models.

For example a model for the formula 3x+2y<3 is assigning 0 to x and 1 to y. Resulting in 2 < 3, which is true.

# 9

There are many theories and most importantly there exist techniques for combining them and still retain decidability.

# 10

So, now that we know about SMT we can use it to check a simple program.
Consider this example in the Imp language we have been studying:
We want to check that, assuming X's initial value is 3,
and that we assign the value of X - 2 to variable Y
and the value of X - 1 to X,
then, in the end, X should have value 2 and Y should have value 1.

$

We can formalise the correctness of this hoare triple by translating to this SMT formula.
Note the usage of different SMT variables for each time the program variables are assigned.
This is so that each variable is assigned at most once in a program.

$

This formula is satisfiable iff the triple is correct.
Meaning that there is some mapping from variables to values such that all clauses are satisfied.

In this case there is only one solution which is: X0=3, X1=2 and Y0=1.

# 11

# 12

So now we know how to check if a program respects a specification.
We only need to find a way to generate possible solutions.

$

The most simple method is to use the grammar of the language to enumerate all programs
until we find one that is correct.

$

There is of course a problem of state space. The number of programs of fixed length is exponential on the number of different expressions or statements available on the language.

# 13

Here we have a grammar tree for the Imp language, so we can see the problem.

# 14

Putting all of this together we can put together our first synthesiser. It simply goes through the grammar tree and checks programs until it finds one that is correct.

$

This method is of course very bad for a lot of different reasons:
- The number of possible programs is infinite, so we would need to successively increase the search depth;
- We generate a lot of programs which will never lead to a solution;
- We are searching the programs almost randomly - there is knowledge we can use to guide the search.

# 15

Some possible improvements to this method would be:

- Use a very restricted language instead of a general purpose programming language - reducing the number of possible programs;

- As we go down the grammar tree partially evaluate programs and check if they can still possibly lead to a solution - allowing us to cut off whole branches at a time;

- Find a way to learn reasons of failure in programs and use them later to prune the search;

- Use types to direct the search;

Among many other approaches.

# 16

So now let's a look at a modern synthesiser.

# 17

Synquid is a recent synthesiser created by Nadia Polikarpova.
It uses polymorphic refinement types to guide the search in the space of programs.

# 18

Refinement types are composed of a "base type" augmented with a logic predicate that restricts the possible values.

$

Here we have an example, i is a variable of type Int, such that i is >= 1 and i is <= 99.
The letter nu is used to represent the value.

# 19

Let's look at a real world usage example.

Suppose you want to create a function that takes a number n and some object x, of type alpha,
and that returns a list containing n copies of x.

So we state that we want to synthesise a function called replicate, that receives a Nat
and an object of unknown type, and returns a list of that type, with length n.

# 20

We also assume a series of auxiliary predicates already exist, like zero, inc, dec, etc.

But how can we be sure that the elements of the list will all be x, and not some other value of type alpha? This is assured because there is no possible way to create new elements of an unkown type, and as such the only option is the use the one given.

$

Let's see how the synthesiser works...
